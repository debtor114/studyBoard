# LIS (Longest Increasing Subsequence)



**주어진 수열 내에서 가장 긴 부분 수열을 찾아내는 알고리즘**



다음과 같은 수열이 주어져있을 때를 생각해보자.

![LIS_array.png](https://github.com/doooooooong/studyBoard/blob/master/algorithm/DP/images/LIS_array.png?raw=true)

위와 같이 주어진 수열에서, LIS 는 10, 20, 50, 90 또는 10, 20, 40, 60 등으로 구해낼 수 있으며 가장 긴 증가하는 부분 수열의 길이는 4라는 걸 직관적으로 구할 수 있다.

하지만 컴퓨터는 직관이 없다. 컴퓨터의 관점(Computational Thinking)으로 코드를 옮겨보자





### DP, O(N^2)의 복잡도

- `dp[i]`: i번째 수를 마지막 원소로 가지는 증가 수열의 길이

- `array[i]`: 데이터 값

  >  ex) arr[0] = 10, arr[1] = 30 ...



```c++
int array[1000]; // 인덱스마다 각 입력값
int dp[1000]; // 인덱스마다 각 증가 수열의 길이
int max = 0;

for(int i = 0; i < N; i++) {
    dp[i] = 1;
    // i 를 기준으로 인덱스 0 에서부터 i-1까지 체크한다 
    // 길이를 기준
    for(int j = 0; j < i; j++) {
        if (array[i] > array[j] && dp[j] + 1 > dp[i]) {
            // 증가 수열
            dp[i] = dp[j] + 1;
        }
    }

    if (max < dp[i]) max = dp[i];
}
```



일단 이중 반복문을 보자.

```c++
for(int i = 0; i < N; i++) {
    ........
for(int j = 0; j < i; j++) {
   ........
	}
}
```



기본적으로 i는 N까지 돌고 두번째 반복문은 0부터 i 전까지 돌게 된다.

배열에 {10, 30, 20, 50, 40, 90, 60} 값이 있다고 가정하자.

i = 1 -> 10 .. (30 (arr[1]) 기준)

i = 2 -> 10, 30 .. (20 (arr[2]) 기준)

i = 3 -> 10, 30 ,20 .. (50 (arr[3]) 기준)

i = 4 -> 10, 30 ,20, 50 .. (40 (arr[4]) 기준)

...

이런 식으로 하나를 기준으로 잡아 루프를 돌게 된다.



그렇다면 다시 전체적인 이중 반복문을 보자.

```c++
for(int i = 0; i < N; i++) {
    dp[i] = 1;
	for(int j = 0; j < i; j++) {
        if (array[i] > array[j] && dp[i] == dp[j]) {
            dp[i] = dp[j] + 1;
        }
    }
}
```

하나를 기준으로 잡아 그 전에 값들을 비교해서 길이를 정하는 방식이다.

기본적으로 어찌되든 길이는 1로 시작한다.

당연히 array[i] 가 array[j]보다 커야하고, 길이를 증가할 수 있는지에 대한 조건을 주게 된다.



길이를 증가할 수 있는지에 대한 조건에 대해 의문이 들 수 있으니 예를 들어보자.

위에서 가정한 예제 중에서 i = 3 -> 10, 30 ,20 .. (50 (arr[3]) 기준)

50을 기준으로 dp[3]의 값은 3이 나와야한다.

하지만 길이에 대한 조건을 뺀 후 돌려보면 알 수 있다.



```c++
if (array[i] > array[j])
    dp[i] = dp[j] + 1;
```



50을 기준으로 차례대로 들려보자.

10, 30 ,20

10 => dp[3] = 2

30 => dp[3] = 3

20 => dp[3] = 4

30은 차례대로 들리는 10, 30, 20보다 크기 때문에 조건에 성립하게 된다.

그 결과 위와 같이 dp의 값이 잘못 나오는 버그가 발생한다.

그렇기 때문에 잘못 갱신돼버리는 경우를 배제시켜야하기 때문에 조건을 추가한다.



이렇게 루프를 돌 때마다 dp 배열에는 해당 기준에 대한 길이가 저장되게 된다.

그렇기 때문에 i가 증가할 때마다 dp 배열에 있는 길이를 사용하여 dp 배열은 계속해서 갱신되어 원하는 값을 얻게 된다. 이렇게 dp 배열 중 가장 큰 값이 가장 긴 증가 수열의 길이가 되는 것이다.







### Binary Search, O(NlogN)의 복잡도

이진 탐색 배우고 완성하겠음
